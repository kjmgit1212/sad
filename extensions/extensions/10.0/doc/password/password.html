<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE></TITLE>
</HEAD>
<BODY LANG="en-US" DIR="LTR">
<P><IMG SRC="../../image001.png" NAME="graphics1" ALIGN=BOTTOM WIDTH=264 HEIGHT=59 BORDER=0></P>
<P><BR><BR>
</P>
<H1 ALIGN=CENTER>Password Rules API</H1>
<P><BR><BR><BR>
</P>
<P ALIGN=CENTER>IBM Security</P>
<P><BR><BR><BR><BR><BR>
</P>
<P ALIGN=CENTER>&copy; Copyright International Business Machines
Corporation 2003, 2012. All rights reserved. <BR>US Government Users
Restricted Rights – Use, duplication or disclosure restricted by
GSA ADP Schedule Contract with IBM Corp.</P>
<P><BR><BR>
</P>
<P>
<A HREF="#purpose">Purpose of this Document</A><BR>
<A HREF="#overview">Overview</A><BR>
<A HREF="#apiDescription">API Description</A><BR>
<A HREF="#apiExample">API Example</A><BR>
<a href="#ruleReg">Rule Registration</a><BR>
<a href="#generatorReg">Generator Registration</a>
</P>
<H2><A NAME="purpose"></A>Purpose of this Document</H2>
<P>The Identity Manager provisioning platform is designed with
extensibility as a primary goal. Many of the architectural components
have been built using frameworks that can make use of custom
extensions. This document describes the framework used within the
Password Rules component of Identity Manager and how it can be
extended for defining custom validation rules and password generation
algorithms. 
</P>
<H2><A NAME="overview"></A>Overview</H2>
<P>The Password Rules API has been developed to provide the
developers a means for adding custom rules to the password validation
engine of Identity Manager or for overriding the default password
generation algorithm that Identity Manager uses. The Identity Manager
password engine will invoke custom logic for both of these purposes
if the steps outlined below are taken.</P>
<P>The Password Rules API is organized at two levels of abstraction.
The base level of abstraction only addresses a generic password
environment. The only context of the password engine is a single
generic object with a password and other general attributes. The
second level of abstraction is specific to provisioning. At this
level, the context of the password engine is assumed to be an
account, whereby the attributes of the account are available, as well
as the attributes of the identity that owns the account and the
service that hosts the account. The engine being extended will
determine the abstraction, or the context, being used when executing
rules. In other words, if the client is customizing the password
engine of a simple identity password management application the base
context will be available, whereas if the client is customizing the
Identity Manager provisioning product the provisioning context will
be available. A better explanation of this will be provided below.</P>
<H2><A NAME="apiDescription"></A>API Description</H2>
<P>The Password Rules API consists of a set of classes that provide
interfaces that clients can implement so that their custom algorithms
can participate in the password validation and password generation
frameworks. This framework is defined by the classes in the
<A HREF="../../api/com/ibm/passwordrules/package-summary.html">com.ibm.passwordrules
package</A>. The UML class diagram in figure 1 below illustrates the
primary objects in these frameworks and their relationships. 
</P>
<div align="center">
<img border=0 width=454 height=187 src="images/image004.gif"><br>
<b>Figure 1: Password Rules Class Diagram</b>
</div>
<P>Rule is an interface that defines the requirements of one specific
password rule. The client will provide an implementation to these
requirements and this interface in order for their custom rule
algorithm to be integrated into the rules framework. A Rule gets its
context, id of password protected object, password history, and other
attributes of the password protected object, from an implementation
of the ValidationInfo interface. The password rules engine generates
the context and provides it to the Rule implementation at the time of
evaluation. 
</P>
<P>The password rules framework supports the merging, or joining, of
multiple rule sets with overlapping rules when validating a single
password. For example, the framework can evaluate to two rule sets,
each defining a minimum length rule. The engine will attempt to
validate the single password against both rules. In this example,
this appears simple, the engine could simply evaluate the password
against the rules one at a time. However, it is not so easy to relay
to a client what the password rule requirements are without listing
them one at a time, which could become overwhelming if there are many
rules and many rule sets that are configured. For this reason, any
class implementing Rule interface is expected to provide logic in a
join() method, which would allow joining parameters of two rules of
the same type and returning that one rule definition. So, in our
example of two rule sets with a minimum length rule, if one rule
defined a minimum length of 6 and the other defined 8, the join()
method on the Rule implementation would return 8. This is the
resulting requirement for the minimum length of a password.</P>
<P>A Rule is also involved in the password generation process. The
PasswordGenerator interface defines the requirements of the password
generation engine. To override the generation algorithm of the
platform, the client can provide an alternative implementation of
this interface. At the time of password generation, the
PasswordGenerator will be passed to each Rule instance in the
framework as a visitor where the Rule can provide information to the
PasswordGenerator to constrain the construction of the password being
generated. For example, if a Rule defines a minimum of 6 characters
is required for a password; this information is provided to the
PasswordGenerator so that it does not generate a password with under
6 characters. Please see the accompanying <A HREF="../../api/index.html">API
Reference Document</A> for more details on the individual objects.</P>
<P>As an extension to the base password rules framework, the Identity
Manager provisioning product provides additional provisioning
specific context information, such as owner and service related
attributes, to the Rules in the framework through the
ProvisioningValidationInfo interface. This interface extends the
ValidationInfo interface. Rule implementations that are built
specifically for provisioning can make use of this information by
down-casting the ValidationInfo object passed to the Rule at
validation time. This, however, makes the Rule implementation
provisioning specific and can not be used in a more general purpose
password management rules engine. The ProvisioningValidationInfo
interface can be found in the <A HREF="../../api/com/ibm/passwordrules/provisioning/package-summary.html">com.ibm.passwordrules.provisioning
package</A>.</P>
<P>There is a set of standard password rules and a standard password
generator provided in the <A HREF="../../api/com/ibm/passwordrules/standard/package-summary.html">com.ibm.passwordrules.standard
package</A>. This package is available by default in an password
rules engine utilizing this framework. Clients of this API can extend
these classes if they wish to add logic to the existing algorithms.</P>
<H2><A NAME="apiExample"></A>API Example</H2>
<P>Please see the accompanying example code with this package.</P>
<H2><a name="ruleReg"></a>Rule Registration</H2>
<P>After a custom password rule has been developed that implements
the Rule interface, that rule must be compiled and placed in the
Identity Manager classpath. At this point the class can be
instantiated within the Identity Manager process, however the
password rules framework does not know that this class should be used
within the engine. The class must then be registered with the engine
by placing the full class name of the new rule in the
passwordrules.properties file. The class is indicated as a key in the
properties file. The prefix for the password rule key is
“password.rule.” The format of the line is password.rule.&lt;class
name&gt;=[true|false]. The line below illustrates registering an
illegal pattern rule implemented by the
com.ibm.itim.examples.IllegalPatternRule class.</P>
<PRE>password.rule.com.ibm.itim.examples.IllegalPatternRule=true</PRE><P>
‘=true' in this example indicates, that the rule requires an input
parameter. <BR><BR>Custom password rule may be one of two types:</P>
<OL>
	<LI>Password rules requies input parameter:<BR>This can be
	configured in the passwordrules.properties file by specifying
	boolean value 'true', after '='. Following additional callback
	methods are called by Identity Manager server to set and get the parameters.
	<ol>
	<li><pre>void setParameter(java.lang.String parameter)</pre>
	<li><pre>String getParameter()</pre>
	</ol>
	<LI>Password rule does not require input parameter:<BR>This can
	be configured in the passwordrules.properties file by specifying a
	boolean value 'false', after '='. In this case, following callback
	methods will NOT be called by Identity Manager server. 
	<ol>
	<li><pre>void setParameter(java.lang.String parameter)</pre>
	<li><pre>String getParameter()</pre>
	</ol>
</OL>
<P>For example, the built-in minimum length rule requires a numeric
parameter indicating what the minimum length is. However, the check
dictionary rule does not need a parameter. It just needs to be
toggled on or off by the administrator. If a rule requires a
parameter, the Identity Manager password rules user interface will
display a text field in which the administrator can provide a value.
It is up to the administrator to format the contents of the parameter
text in the way expected by the custom rule implementation. The
password rules engine will pass unprocessed contents of the text
field to the custom rule implementation class.</P>
<P>Finally, in order to provide an intuitive queue to the password
rules administrator in the user interface, a label can be associated
with the rule. This label, as are all labels in Identity Manager, can
be localized. The label is defined in the CustomLabels.properties
with other labels, using a key=label property format. The key will be
the same full class name of the Rule implementation and the label can
be any text. To complete our example of the illegal pattern rule, the
following line would be added to CustomLabels.properties:</P>
<PRE>password.rule.com.ibm.itim.examples.IllegalPatternRule=Illegal Pattern:</PRE><H2>
<a name="generatorReg"></a>Generator Registration</H2>
<P>Just as custom password rules must be registered with the Identity
Manager engine, so must custom password generators. The custom
password generator class must first be compiled and placed in the
Identity Manager classpath. Then the class must be specified in the
passwordrules.properties file. The prefix of the generator property
is “generator.” The full class name of the custom generator class
is appended to that prefix. The line below illustrates registering a
custom password generator implemented by the
com.ibm.itim.examples.CustomGenerator class.</P>
<PRE>generator.com.ibm.itim.examples.CustomGenerator</PRE><P>
If initialization context information is required for the custom
generator implementation, they can be specified in the
passwordrules.properties file as a value to the generator class key
shown above. The format is generator.&lt;class name&gt;=&lt;context
information&gt;. This information will be passed to the custom
class’s initialize() method. In our CustomGenerator example, we
will add two parameters that indicate we are using the generator in a
provisioning system and that we’re deployed in a government
environment. Since the property key-value pair format does not
support multiple values out-of-the-box, we have delimited our value
data. This is only an example as the engine will pass everything
after the ‘=’ as one string to the initialize() call anyway.</P>
<PRE>generator.com.ibm.itim.examples.CustomGenerator=provisioning?government</PRE><P>
The value of the string passed to CustomGenerator’s initialize()
method will be “provisioning?government”.</P>
</BODY>
</HTML>